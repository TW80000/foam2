/**
 * @license
 * Copyright 2019 The FOAM Authors. All Rights Reserved.
 * http://www.apache.org/licenses/LICENSE-2.0
 */

foam.CLASS({
  package: 'foam.box',
  name: 'SessionReplyBox',
  extends: 'foam.box.ProxyBox',

  requires: [
    'foam.box.SessionClientBox',
    'foam.box.RPCErrorMessage'
  ],

  imports: [
    'requestLogin',
    'sessionTimer',
    'group'
  ],

  javaImports: [
    'foam.nanos.auth.AuthenticationException',
    'foam.util.SafetyUtil'
  ],

  properties: [
    {
      class: 'FObjectProperty',
      name: 'msg',
      type: 'foam.box.Message'
    },
    {
      class: 'FObjectProperty',
      name: 'clientBox',
      type: 'foam.box.Box'
    },
    {
      class: 'Boolean',
      name: 'promptUserToAuthenticate',
      value: true
    }
  ],

  methods: [
    {
      name: 'send',
      code: function send(msg) {
        if (
          this.RPCErrorMessage.isInstance(msg.object) &&
          msg.object.data.id === 'foam.nanos.auth.AuthenticationException'
        ) {
          var storedSessionToken = localStorage.getItem(this.clientBox.sessionName);
          if ( this.msg.attributes[this.clientBox.SESSION_KEY] !== storedSessionToken ) {
            // The user authenticated and thus the session's access token
            // changed. Send the request again but with the updated session
            // token.
            this.clientBox.sessionID = storedSessionToken;
            this.clientBox.send(this.msg);
            return;
          } else if ( this.promptUserToAuthenticate ) {
            this.requestLogin().then(() => {
              this.clientBox.send(this.msg);
            });
            return;
          }
        }

        // fetch the soft session limit from group, and then start the timer
        if ( this.group && this.group.id !== '' && this.group.softSessionLimit !== 0 ) {
          this.sessionTimer.startTimer(this.group.softSessionLimit);
        }

        // Store the session id generated by the server so we can use it in
        // subsequent requests.
        if ( msg.attributes.sessionId ) {
          if ( this.SessionClientBox.isInstance(this.clientBox) ) {
            this.clientBox.sessionID = msg.attributes.sessionId;
          } else {
            throw new Error(`The client box of SessionReplyBox must be an instance of SessionClientBox, otherwise we can't update the session id on the client when the server changes it.`);
          }
        }

        this.delegate.send(msg);
      },
      javaCode: `
        Object object = msg.getObject();
        SessionClientBox clientBox = (SessionClientBox) getClientBox();

        if (
          object instanceof RPCErrorMessage &&
          ((RPCErrorMessage) object).getData() instanceof RemoteException &&
          "foam.nanos.auth.AuthenticationException".equals(((RemoteException) ((RPCErrorMessage) object).getData()).getId())
        ) {
          String storedSessionToken = (String) clientBox.getX().get(clientBox.getSessionName());
          if ( ! ((String) getMsg().getAttributes().get("sessionId")).equals(storedSessionToken) ) {
            // The user authenticated and thus the session's access token
            // changed. Send the request again but with the updated session
            // token.
            clientBox.setSessionID(storedSessionToken);
            clientBox.send(getMsg());
            return;
          } else if ( getPromptUserToAuthenticate() ) {
            // TODO: should this be wrapped in new Thread() ?
            ((Runnable) getX().get("requestLogin")).run();
            getClientBox().send(getMsg());
            return;
          }
        }

        String newSessionId = (String) msg.getAttributes().get("sessionId");

        if ( ! SafetyUtil.isEmpty(newSessionId) ) {
          clientBox.setSessionID(newSessionId);
        }

        getDelegate().send(msg);
      `
    }
  ]
});
